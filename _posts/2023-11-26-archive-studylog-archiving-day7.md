---
title: "[국비지원과정 Day 6-7] Java"
excerpt: "국비 수강기록6. 240828 블로그 옮김"

categories:
  - Archive
tags:
  - [국비지원, Java]

permalink: /archive/studylog-archiving-day7/

toc: true
toc_sticky: true

date: 2023-11-26
last_modified_at: 2024-08-28
---

## 📕ch11 추상화 & 인터페이스

*1. 추상 클래스 & 추상 메서드*
- 추상 클래스(abstract class): 미완성 메서드(추상 메서드)를 포함하고 있는 클래스. 미완성 설계도<br/>
인스터스를 생성할 수 없으며, 여러 클래스에 공통적인 부분을 뽑아내어 표준화하기 위한 용도로 활용된다.
- 추상 메서드(abstract method): 메서드의 선언부만 작성하고 구현부가 없는 메서드.<br/>
실제 수행될 내용이 작성되지 않은 미완성 상태이기 때문에, 이를 상속받은 하위 클래스에서 오버라이딩을 통해 구현한다.<br/>
\*cf. 추상화: 클래스에서 공통적인 변수와 메서드를 사용해 코드를 표준화 시키기 위한 작업
  ```
  /* 주석을 통해 어떤 기능을 수행할 목적으로 작성하였는지 설명한다. */
  /* 선언부만 존재 */
  abstract 리턴타입 메서드이름();
  ```

*2. 인터페이스*
- 추상 클래스의 일종. 추상 메서드와 상수만을 멤버로 가질 수 있으며, 추상클래스보다 추상화 정도가 높다.
- 인터페이스를 사용하는 이유, 장점<br/>
(1) 유연한 설계가 가능하고 유지보수를 용이하게 하여 개발시간을 단축시킬 수 있다.<br/>
(2) 표준화가 가능하다.<br/>
(3) 서로 상속관계이거나, 같은 상위클래스를 공유하는 등의 상호관계에 있지 않아도 하나의 인터페이스를 공통적으로 구현하도록 함으로써 클래스들 간의 관계를 맺어줄 수 있다.<br/>
(4) 클래스의 선언과 구현을 분리시길 수 있기 때문에, 실제 구현에 독립적인 프로그래밍이 가능하다.

  ```
  interface 인터페이스이름 {
    public static final 타입 상수이름 = 값;
      public abstract 메서드이름(매개변수목록);
  }
  ```
- 인터페이스는 인터페이스로부터만 상속받을 수 있으며, 다중상속이 가능하다.
- 인터페이스의 구현(implements): 인터페이스 그 자체로는 인스턴스 생성이 불가능하기 때문에 상속을 통해 추상 메서드를 완성한다. 이 경우, 키워드로 __implements__ 를 사용하여 구분한다.<br/>
\*cf. 구현하는 __인터페이스에 정의된 추상메서드 중 일부만 구현__ 하는 경우, __abstract__ 를 붙여서 추상클래스로 선언해야한다.
  ```
  class 클래스이름 extends 상위클래스 implements 인터페이스{
    //인터페이스에 정의된 모든 추상메서드를 구현해야 한다.
  }
  ```

  <br/>

## 📕ch12 기본 클래스 활용: Object, String, Math, Wrapper

\*cf. java.lang패키지: 는 Java 프로그래밍에 가장 기본이 되는 클래스를 포함하고 있는 패키지. import문 없이 바로 사용 가능하다.

*1. Object class: 모든 클래스의 최상위 클래스*

![](https://velog.velcdn.com/images/92miindy/post/76ea3377-04a5-49a5-abd5-2767ceb1c144/image.png)

*2. String class: 문자열을 저장하고 이를 다루는데 필요한 메서드를 제공*

- String의 불변성(immutable): 스트링의 내용은 final문자배열에 저장된다. 한번 생성된 String인스턴스가 갖고 있는 문자열은 읽어 올 수 만 있고 수정이 불가능하다. 
- String의 내용비교<br/>
\- A.equals(B): A와 B의 문자열(내용)을 비교. 타입이 String이 아니거나 문자열이 다르면 false를 반환<br/>
\- A == B: A와 B의 주소값을 비교.<br/>
- String의 초기화: 빈 문자열(""), null(객체가 가리키는 데이터가 없는 상태) 활용<br/>
\*cf. NullPointerException: 참조변수가 가리키는 내용이 없는 상태에서 연산을 실행했을 때, 예외발생
- StringBuffer & StringBuilder 클래스: String클래스와 달리 내용을 변경할 수 있는 클래스

*3. Math class: 수학계산에 유용한 기본적인 메서드 및 상수(자연수 E, 원주율 PI)를 정의해 놓은 클래스*

![](https://velog.velcdn.com/images/92miindy/post/ff8889de-423a-4091-a665-0914cb4785dd/image.png)

*4. Wrapper class: 기본형 값을 객체로 변환하여 작업을 수행할 수 있도록 8개의 기본 자료형을 클래스로 정의해 놓은 클래스.*

![](https://velog.velcdn.com/images/92miindy/post/9727a33c-724c-445f-a823-c48f3a69e067/image.png)

<br/>

## 📕ch13 컬렉션 & 제네릭스

- 컬렉션: 집합데이터를 저장할 수 있는 자료형. 컬렉션 클래스들은 배열의 단점을 보완하기 위해 만들어진  것으로, 배열에 비해 속도가 느리고 메모리 사용량이 증가한다.
- 컬렉션 프레임웍: 데이터 군을 저장하는 클래스들을 표중화한 설계(프로그래밍 방식)<br/>
\*ex. ArrayList, HashSet, HashMap 등<br/>
\*cf. 배열의 단점 : Object 배열 제외 같은 자료형만 저장 가능, 사이즈가 고정적.  추가/삭제가 어려움<br/>

*1. 컬렉션 종류*

(1) List: 순서가 있는 데이터의 집합. 터이터의 중복값을 허용하며 인덱스로 조회가 가능하다.
- List의 생성 및 활용
  ```
  List<자료형> 참조변수 = new ArrayList<자료형>();
  참조변수.size(); 	//데이터의 개수	
  참조변수.add(값);	//데이터 추가
  참조변수.add(인덱스,값);	//해당 인덱스에 데이터 추가
  참조변수.get(인덱스);	//데이터 읽어오기: 
  참조변수.remove(인덱스);	//데이터 삭제:
  ```

(2) Set: 순서를 유지하지 않는 데이터의 집합. 중복값을 허용하지 않는다. <br/>
(3) Map: key와 value의 한 쌍으로 이루어진 데이터의 집합으로 대량의 자료를 조회할 때 유리한 구조. 데이터가 저장되는 순서는 없다. key(변수명, 중복X)로 조회가 가능하고, value는 중복을 허용한다.
- 맵(HashMap) 활용
  ```
  맵.put(key, value)	//데이터 추가
  맵.get(key)	//데이터 조회
  ```

![](https://velog.velcdn.com/images/92miindy/post/8a2be763-d5c3-46ad-aaca-3f6b1a44cae3/image.png)

<br/>

*2. 제네릭스(Generics)*
- 하나의 클래스로 다양한 자료형의 데이터를 처리할 수 있는 방법.
- 컴파일 시 타입체크를해주는 기능
- 타입체크와 형변환 생략으로 코드가 간결해지고, 객체의 타입 안정성을 제공한다.
  ```
  class 클래스명<T> {}
  ```

<br/>

## 📕14 예외처리

- 어떤 원인으로 인해 프로그램이 비정상적으로 종료되는것을 막고, 정상적인 실행상태를 유지할 수 있도록 안전하게 처리하는 작업
- 프로그램 실행 시 발생할 수있는 예외에 대비한 코드를 작성한다.
- 발생원인: 네트워크 장애,사용권한 관련 문제, 존재하지 않는 파일 이름 입력, 입력값의 형식이 다른 경우, 연산 오류

<br/>

(1) 프로그램 오류
- 발생시점에 따라<br/>
컴파일 에러: 컴파일 시에 발생하는 에러<br/>
런타임 에러: 프로그램 실행 시에 발생하는 에러<br/>
논리적 에러 : 프로그램 실행은 되지만, 의도와 다르게 동작하는 것

- 에러, 경고, 예외	<br/>
Error:     컴파일이 안됨<br/>
Warning: 실행은 되지만 성능 저하 등의 문제가 발생할 가능성이 있는 코드<br/>
Exception: 컴파일과 실행은 되지만 프로그램이 비정상적으로 종료되는 경우

<br/>

(2) 예외 처리를 하는 경우
- 선택적인 예외 처리 : 예상되는 코드에 처리
- 필수적인 예외 처리 : 파일입출력, 네트워크 관련 작업, DB연동 등

<br/>

(3) 예외처리
- try ~ catch 구문
  ```
  try {
      예외가 발생할 가능성이 있는 코드
  } catch(Exception e) {
      예외가 발생했을 때의 코드
  } finally {
    예외 발생 여부에 관계없이 항상 실행되는 코드
  }
  ```

- throws 구문: 키워드 throw를 사용해 고의로 예외를 발생시킬수도 있다.
  ```
  Exception e= new Exception( ) ;
  throw e;  
  // 고의로 예외를 발생시킴

  void method() throws 예외처리클래스 {}
  ```
 
- 예외가 발생할 경우의 해결 방법
  ```
  e.printStackTrace(); 
  //명령어로 예외의 원인을 확인하고 해결할 수 있다.
  //예외 발생 당시의 호출스택에 있었던 메서드의 정보와 예외 메시지를 화면에 출력함.

  getMessage(); 	
  //발생한 예외 클래스의 인스턴스에 저장된 메시지를 얻을 수 있다.
  ```

<br/>

## 📕15 프로세스(Process)와 스레드(Thread)
- 프로세스(Process) : 실행중인 프로그램
- 스레드(Thread)    : 프로세스 내에서의 작업 단위. 모든 프로세스에는 최소 하나 이상의 스레드가 존재함.

<br/>

*1. 멀티 스레드*
- Single Thread : 하나의 프로그램에 하나의 작업단위만 있음. 순차적 처리
- Multi Thread: 하나의 프로그램에 2개 이상의 작업단위가 있음.  동시에 여러기능을 같이 처리함(순서X)<br/>
하나의 새로운 프로세스를 생성하는 것보다 하나의 새로운 Thread를 생성하는 것이 더 적은 비용이 든다.
- Multi Thread의 장단점<br/>
장점: 사용자에게 편리한 서비스 제공<br/>
단점: 순서가 중요한 작업의 경우에는 주의가 필요하다. 교착상태(dead-lock)가 발생하지 않도록 주의해야 한다.

<br/>

*2. Thread의 구현과 실행*

(1) Thread 클래스를 상속받는 방법
- Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없다.(Java에서는 다중상속이 불가)
  ```
  class MyThread extends Thread {
    public void run() { /*작업내용*/ } 	
    //Thread클래스의 run() 을 오버라이딩
  }
  ```

(2) Runnable 인터페이스를 구현하는 방법
- Runnable 인터페이스의 추상메서드인  run()의 구현부{}를 완성한다.
- Runnable 인터페이스를 구현한 경우: 인터페이스를 구현한 클래스의 인스턴스를 생성한 후, 이 인스턴스를 Thread클래스의 생성자의 매개변수로 제공해야한다.
  ```
  class MyThread implements Runnable {
    public void run() { /*작업내용*/ }	
    //Runnable 인터페이스의 run() 을 구현
  }
  ```

![](https://velog.velcdn.com/images/92miindy/post/0d719d57-ce5e-4026-b1f4-76570e9950cd/image.png)

<br/>

*3. 스레드의 실행*

- start() 를 호출: 스레드를 생성하면 바로 실행되는 것이 아닌 "실행대기 상태"가 되며, start() 를 호출해야만 스레드가 실행된다.
- 한 번 실행이 종료된 스레드는 다시 실행할 수 없다. 즉, 하나의 스레드에 대해 start()는 한번만 호출될 수 있다.
